<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guochen-whu.github.io/"/>
  <updated>2017-11-30T14:24:22.506Z</updated>
  <id>http://guochen-whu.github.io/</id>
  
  <author>
    <name>郭琛</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mobx 源码解读（七） mobx-react</title>
    <link href="http://guochen-whu.github.io/2017/11/17/Mobx-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%83%EF%BC%89-mobx-react/"/>
    <id>http://guochen-whu.github.io/2017/11/17/Mobx-源码解读（七）-mobx-react/</id>
    <published>2017-11-17T12:59:18.000Z</published>
    <updated>2017-11-30T14:24:22.506Z</updated>
    
    <content type="html"><![CDATA[<p>Writing…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Writing…&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Mobx" scheme="http://guochen-whu.github.io/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>Mobx 源码解读（六） Action</title>
    <link href="http://guochen-whu.github.io/2017/11/17/Mobx-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E5%85%AD%EF%BC%89-Action/"/>
    <id>http://guochen-whu.github.io/2017/11/17/Mobx-源码解读（六）-Action/</id>
    <published>2017-11-17T12:47:39.000Z</published>
    <updated>2017-12-02T05:10:22.620Z</updated>
    
    <content type="html"><![CDATA[<p>Mobx 提供 action API 供用户声明修改应用状态的函数。Mobx 进行了一层简单的包装，提供事务功能，可以在 action 内进行多次 Observable 的修改，而不用担心 Reaction 的多次重新执行；同时支持 spy，可以在开发工具中观察到 action 的执行。</p><a id="more"></a><p>action API 的入口如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> action: IActionFactory = <span class="function"><span class="keyword">function</span> <span class="title">action</span>(<span class="params">arg1, arg2?, arg3?, arg4?</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// action(fn)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span> &amp;&amp; <span class="keyword">typeof</span> arg1 === <span class="string">"function"</span>)</span><br><span class="line">    <span class="keyword">return</span> createAction(arg1.name || <span class="string">"&lt;unnamed action&gt;"</span>, arg1)</span><br><span class="line">  <span class="comment">// action(name, fn)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">"function"</span>) <span class="keyword">return</span> createAction(arg1, arg2)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @action(name)</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span> &amp;&amp; <span class="keyword">typeof</span> arg1 === <span class="string">"string"</span>) <span class="keyword">return</span> namedActionDecorator(arg1)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @action</span></span><br><span class="line">  <span class="comment">// arg2 就是属性名，作为默认 name</span></span><br><span class="line">  <span class="keyword">return</span> namedActionDecorator(arg2).apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="built_in">any</span></span><br></pre></td></tr></table></figure><h2 id="Action-原理"><a href="#Action-原理" class="headerlink" title="Action 原理"></a>Action 原理</h2><p>先来看 createAction 函数的实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAction</span>(<span class="params">actionName: <span class="built_in">string</span>, fn: <span class="built_in">Function</span></span>): <span class="title">Function</span> &amp; <span class="title">IAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeAction(actionName, fn, <span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原函数作为属性添加到包装后的函数上</span></span><br><span class="line">  ;(res <span class="keyword">as</span> <span class="built_in">any</span>).originalFn = fn</span><br><span class="line">  <span class="comment">// 标志位</span></span><br><span class="line">  ;(res <span class="keyword">as</span> <span class="built_in">any</span>).isMobxAction = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，只是返回了一个经过 executeAction 包装的函数。executeAction 在原函数的执行前后，分别调用了 startAction 和 endAction：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeAction</span>(<span class="params">actionName: <span class="built_in">string</span>, fn: <span class="built_in">Function</span>, scope?: <span class="built_in">any</span>, args?: IArguments</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> runInfo = startAction(actionName, fn, scope, args)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(scope, args)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    endAction(runInfo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startAction 会先调用 untrackedStart 函数，将当前（可能有）正在跟踪的 Derivation 置为 null，避免依赖收集。然后调用 startBatch 开始一个新事务，确保 action 结束后才开始 Derivation 的重新计算。最后，将全局的标志位 allowStateChanges 置为 true。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAction</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  actionName: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  fn: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  scope: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  args?: IArguments</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">IActionRunInfo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可能有 Derivation 正在重新计算，先暂停</span></span><br><span class="line">  <span class="keyword">const</span> prevDerivation = untrackedStart()</span><br><span class="line">  startBatch()</span><br><span class="line">  <span class="comment">// 全局标志 allowStateChange 置为 true</span></span><br><span class="line">  <span class="keyword">const</span> prevAllowStateChanges = allowStateChangesStart(<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    prevDerivation,</span><br><span class="line">    prevAllowStateChanges,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/derivation.ts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">untrackedStart</span>(<span class="params"></span>): <span class="title">IDerivation</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prev = globalState.trackingDerivation</span><br><span class="line">  globalState.trackingDerivation = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>action 执行完后，调用 endAction 还原两个全局变量，结束事务。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">endAction</span>(<span class="params">runInfo: IActionRunInfo</span>) </span>&#123;</span><br><span class="line">  allowStateChangesEnd(runInfo.prevAllowStateChanges)</span><br><span class="line">  endBatch()</span><br><span class="line">  untrackedEnd(runInfo.prevDerivation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作为装饰器使用"><a href="#作为装饰器使用" class="headerlink" title="作为装饰器使用"></a>作为装饰器使用</h2><p>在 action 入口函数中会进入第三、四个分支，调用 namedActionDecorator 生成一个装饰器函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">namedActionDecorator</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个函数只是做了一些边界条件的检查</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, prop, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (descriptor &amp;&amp; <span class="keyword">typeof</span> descriptor.value === <span class="string">"function"</span>) &#123;</span><br><span class="line">      descriptor.value = createAction(name, descriptor.value)</span><br><span class="line">      descriptor.enumerable = <span class="literal">false</span></span><br><span class="line">      descriptor.configurable = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> descriptor</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (descriptor !== <span class="literal">undefined</span> &amp;&amp; descriptor.get !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"[mobx] action is not expected to be used with getters"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际上装饰器函数还是通过 createClassPropertyDecorator 创建的</span></span><br><span class="line">    <span class="keyword">return</span> actionFieldDecorator(name).apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是使用 createClassPropertyDecorator 生成装饰器函数（参看第三篇）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actionFieldDecorator = createClassPropertyDecorator(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, args, originalDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> actionName =</span><br><span class="line">      args &amp;&amp; args.length === <span class="number">1</span> ? args[<span class="number">0</span>] : value.name || key || <span class="string">"&lt;unnamed action&gt;"</span></span><br><span class="line">    <span class="keyword">const</span> wrappedAction = action(actionName, value)</span><br><span class="line">    <span class="comment">// 将包装后的 action 作为隐藏属性添加到类实例上</span></span><br><span class="line">    addHiddenProp(target, key, wrappedAction)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不允许赋值</span></span><br><span class="line">    invariant(<span class="literal">false</span>, getMessage(<span class="string">"m001"</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样在类实例化时，包装好的 action 就作为隐藏属性添加到了类实例上。</p><h2 id="action-bound-绑定上下文"><a href="#action-bound-绑定上下文" class="headerlink" title="action.bound 绑定上下文"></a>action.bound 绑定上下文</h2><p>在 creatAction 函数中可以看到，action 使用默认的上下文：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> executeAction(actionName, fn, <span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 action.bound 可以将 this 绑定到对象或类实例上：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineBoundAction</span>(<span class="params">target: <span class="built_in">any</span>, propertyName: <span class="built_in">string</span>, fn: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 上下文对象为 target</span></span><br><span class="line">    <span class="keyword">return</span> executeAction(propertyName, fn, target, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ;(res <span class="keyword">as</span> <span class="built_in">any</span>).isMobxAction = <span class="literal">true</span></span><br><span class="line">  addHiddenProp(target, propertyName, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runInAction"><a href="#runInAction" class="headerlink" title="runInAction"></a>runInAction</h2><p>action(fn)() 的语法糖，直接调用了 executeAction:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runInAction</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg1, arg2?, arg3?</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> actionName = <span class="keyword">typeof</span> arg1 === <span class="string">"string"</span> ? arg1 : arg1.name || <span class="string">"&lt;unnamed action&gt;"</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">typeof</span> arg1 === <span class="string">"function"</span> ? arg1 : arg2</span><br><span class="line">  <span class="keyword">const</span> scope = <span class="keyword">typeof</span> arg1 === <span class="string">"function"</span> ? arg2 : arg3</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> executeAction(actionName, fn, scope, <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mobx 提供 action API 供用户声明修改应用状态的函数。Mobx 进行了一层简单的包装，提供事务功能，可以在 action 内进行多次 Observable 的修改，而不用担心 Reaction 的多次重新执行；同时支持 spy，可以在开发工具中观察到 action 的执行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mobx" scheme="http://guochen-whu.github.io/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>Mobx 源码解读（四） Reaction</title>
    <link href="http://guochen-whu.github.io/2017/11/17/Mobx-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E5%9B%9B%EF%BC%89-Reaction/"/>
    <id>http://guochen-whu.github.io/2017/11/17/Mobx-源码解读（四）-Reaction/</id>
    <published>2017-11-17T04:39:39.000Z</published>
    <updated>2017-12-02T03:48:52.405Z</updated>
    
    <content type="html"><![CDATA[<p>Reaction 是一类的特殊的 Derivation，可以注册响应函数，使之在条件满足时自动执行。常用于触发副作用，比如打印日志、更新 DOM 或者发送网络请求。</p><a id="more"></a><p>Reaction 的生命周期可以用下图表示：</p><p><img src="./Reaction示意.png" alt="Reaction示意"></p><ol><li>Reaction 在创建之后初次执行或依赖过期时，会加入到全局的 pendingReactions 队列中</li><li>pendingReactions 中的 Reaction 重新执行</li><li>onInvalidate 调用，执行响应函数。</li><li>响应函数执行，同时收集依赖，即「运行时依赖收集」</li></ol><p>使用 autorun, when 等 api，创建 Reaction 后，会立即执行该 Reaction 的 schedule 方法。第二篇中提到，Observable 在 reportChanged 时，也会调用这个方法将 Reaction 加入到全局的待执行队列中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">schedule() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._isScheduled) &#123;</span><br><span class="line">    <span class="keyword">this</span>._isScheduled = <span class="literal">true</span></span><br><span class="line">    globalState.pendingReactions.push(<span class="keyword">this</span>)</span><br><span class="line">    runReactions()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前不同，这时的 runReactions 会立即执行 pendingReactions 中的所有 Reaction：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReactions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此时不在事务当中，且没有 Reaction 正在执行</span></span><br><span class="line">  <span class="keyword">if</span> (globalState.inBatch &gt; <span class="number">0</span> || globalState.isRunningReactions) <span class="keyword">return</span></span><br><span class="line">  reactionScheduler(runReactionsHelper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reaction 初次执行时会第一次收集依赖，此后当依赖发生变化时，它被加入 pendingReactions 中，并在下一次事务结束时重新执行，更新依赖。接下来看看 Reaction 执行过程中是如何完成依赖的收集和更新的：</p><h2 id="Reaction-执行过程"><a href="#Reaction-执行过程" class="headerlink" title="Reaction 执行过程"></a>Reaction 执行过程</h2><p>runReactionsHelper 依次执行 pendingReactions 中所有的 Reaction：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定 Reaction 计算的最大迭代次数，避免 Reaction 重新触发自身造成死循环</span></span><br><span class="line"><span class="keyword">const</span> MAX_REACTION_ITERATIONS = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际执行 Reaction 重新计算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReactionsHelper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  globalState.isRunningReactions = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> allReactions = globalState.pendingReactions</span><br><span class="line">  <span class="keyword">let</span> iterations = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当执行 Reaction 时，可能触发新的 Reaction(Reaction 内允许设置 Observable的值)，加入到 pendingReactions 中</span></span><br><span class="line">  <span class="comment">// 所以这里使用了两层循环，外层检查确保新加入的 Reaction 也会得到执行</span></span><br><span class="line">  <span class="comment">// 内层每次清空当前 Reaction 数组，并迭代处理当前所有 Reaction</span></span><br><span class="line">  <span class="keyword">while</span> (allReactions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 限制最大迭代次数</span></span><br><span class="line">    <span class="keyword">if</span> (++iterations === MAX_REACTION_ITERATIONS) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">`Reaction doesn't converge to a stable state after <span class="subst">$&#123;MAX_REACTION_ITERATIONS&#125;</span> iterations.`</span> +</span><br><span class="line">            <span class="string">` Probably there is a cycle in the reactive function: <span class="subst">$&#123;allReactions[0]&#125;</span>`</span></span><br><span class="line">      )</span><br><span class="line">      allReactions.splice(<span class="number">0</span>) <span class="comment">// 清空 pendingReactions 数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空 pendingReactions 数组，遍历所有 pendingReactions</span></span><br><span class="line">    <span class="keyword">let</span> remainingReactions = allReactions.splice(<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = remainingReactions.length; i &lt; l; i++)</span><br><span class="line">      <span class="comment">// 依次调用 runReaction 方法</span></span><br><span class="line">      remainingReactions[i].runReaction()</span><br><span class="line">  &#125;</span><br><span class="line">  globalState.isRunningReactions = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pendingReactions 中的 Reaction 依次调用 runReaction 方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">runReaction() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.isDisposed) &#123;</span><br><span class="line">    startBatch()</span><br><span class="line">    <span class="comment">// 「是否待重新计算」的标志置为 false</span></span><br><span class="line">    <span class="keyword">this</span>._isScheduled = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 根据 dependenciesState 判断是否需要重新计算，-1,0,2三种状态好判断，</span></span><br><span class="line">    <span class="comment">// 计算值特有的1状态参看本系列第三篇文章</span></span><br><span class="line">    <span class="keyword">if</span> (shouldCompute(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="comment">// 「正在收集依赖过程中」的标志置为 true</span></span><br><span class="line">      <span class="keyword">this</span>._isTrackPending = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 构造时传入的 onInvalidate</span></span><br><span class="line">      <span class="keyword">this</span>.onInvalidate()</span><br><span class="line">      <span class="comment">// 通知 spy</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._isTrackPending &amp;&amp; isSpyEnabled()) &#123;</span><br><span class="line">        spyReport(&#123;</span><br><span class="line">          object: <span class="keyword">this</span>,</span><br><span class="line">          <span class="keyword">type</span>: <span class="string">"scheduled-reaction"</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    endBatch()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里调用了 onInvalidate，该函数可以在响应函数执行之前做一些判断，控制响应函数执行的「时机」。</p><p>Mobx 提供了 autorun, when, autorunAsync 等 api 用于创建 Reaction，它们的区别就在于构造 Reaction 时传入的 onInvalidate 函数不同：</p><h2 id="不同类型的-Reaction"><a href="#不同类型的-Reaction" class="headerlink" title="不同类型的 Reaction"></a>不同类型的 Reaction</h2><h3 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a>autorun</h3><p>autorun 的 onInvalidate 会直接执行 Reaction 的 track 方法，也就是说，只要 Reaction 执行，就会执行响应函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorun</span>(<span class="params">arg1: <span class="built_in">any</span>, arg2: <span class="built_in">any</span>, arg3?: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="built_in">string</span>, view: <span class="function">(<span class="params">r: IReactionPublic</span>) =&gt;</span> <span class="built_in">any</span>, scope: <span class="built_in">any</span></span><br><span class="line">  <span class="comment">// 参数处理...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以提供 this 值作为第三个参数</span></span><br><span class="line">  <span class="keyword">if</span> (scope) view = view.bind(scope)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二个参数即`onInvalidate`</span></span><br><span class="line">  <span class="comment">// onInvalidate 未进行任何判断，直接调用 track 方法</span></span><br><span class="line">  <span class="keyword">const</span> reaction = <span class="keyword">new</span> Reaction(name, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.track(reactionRunner)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// view 即我们传入的函数，可以拿到 Reaction 实例作为参数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reactionRunner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    view(reaction)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 schedule 方法，第一次执行并收集依赖</span></span><br><span class="line">  reaction.schedule()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回该 Reaction 的 Disposer</span></span><br><span class="line">  <span class="keyword">return</span> reaction.getDisposer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autorunAsync"><a href="#autorunAsync" class="headerlink" title="autorunAsync"></a>autorunAsync</h3><blockquote><p>autorunAsync(action: () =&gt; void, minimumDelay?: number, scope?)</p></blockquote><p>节流版 autorun，在 minimumDelay 时间内只会执行一次响应函数。通过在 onInvalidate 内做节流处理来实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorunAsync</span>(<span class="params">arg1: <span class="built_in">any</span>, arg2: <span class="built_in">any</span>, arg3?: <span class="built_in">any</span>, arg4?: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="built_in">string</span>, func: <span class="function">(<span class="params">r: IReactionPublic</span>) =&gt;</span> <span class="built_in">any</span>, delay: <span class="built_in">number</span>, scope: <span class="built_in">any</span></span><br><span class="line">  <span class="comment">// 参数处理...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (scope) func = func.bind(scope)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节流处理</span></span><br><span class="line">  <span class="keyword">let</span> isScheduled = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> r = <span class="keyword">new</span> Reaction(name, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isScheduled) &#123;</span><br><span class="line">      isScheduled = <span class="literal">true</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        isScheduled = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (!r.isDisposed) r.track(reactionRunner)</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reactionRunner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    func(r)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  r.schedule()</span><br><span class="line">  <span class="keyword">return</span> r.getDisposer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><blockquote><p>when(debugName?, predicate: () =&gt; boolean, effect: () =&gt; void, scope?)</p></blockquote><p>when 在 predicate 函数返回 true 时执行，通过在 onInvalidate 进行这个判断来实现。另外，它只执行一次就销毁，所以它的 onInvalidate 不调用 track 去收集依赖，直接执行响应函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">when</span>(<span class="params">arg1: <span class="built_in">any</span>, arg2: <span class="built_in">any</span>, arg3?: <span class="built_in">any</span>, arg4?: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="built_in">string</span>, predicate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">boolean</span>, effect: Lambda, scope: <span class="built_in">any</span></span><br><span class="line">  <span class="comment">// 参数处理...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> disposer = autorun(name, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 满足 predicate</span></span><br><span class="line">    <span class="keyword">if</span> (predicate.call(scope)) &#123;</span><br><span class="line">      r.dispose()</span><br><span class="line">      <span class="keyword">const</span> prevUntracked = untrackedStart()</span><br><span class="line">      <span class="comment">// 直接执行 effect</span></span><br><span class="line">      ;(effect <span class="keyword">as</span> <span class="built_in">any</span>).call(scope)</span><br><span class="line">      untrackedEnd(prevUntracked)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> disposer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时依赖收集"><a href="#运行时依赖收集" class="headerlink" title="运行时依赖收集"></a>运行时依赖收集</h2><p>Reaction 的 track 方法会执行响应函数并进行依赖收集，也就是「运行时依赖收集」的过程。</p><p>track 方法本身只是做了开始一个新事务，一些标志属性的修改和通知 spy 等工作。</p><p>运行时依赖收集的核心步骤在 trackDerivedFunction 函数中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行响应函数，同时收集依赖</span></span><br><span class="line">function trackDerivedFunction&lt;T&gt;(derivation: IDerivation, f: () =&gt; T, context) &#123;</span><br><span class="line">  <span class="comment">// 将该 Derivation 的 dependenciesState 和当前所有依赖的 lowestObserverState 设为最新</span></span><br><span class="line">  changeDependenciesStateTo0(derivation)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预分配足够的空间？？</span></span><br><span class="line">  derivation.newObserving = <span class="keyword">new</span> <span class="built_in">Array</span>(derivation.observing.length + <span class="number">100</span>)</span><br><span class="line">  <span class="comment">// 记录新的依赖的数量</span></span><br><span class="line">  derivation.unboundDepsCount = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 每次执行都分配一个 uid</span></span><br><span class="line">  derivation.runId = ++globalState.runId</span><br><span class="line">  <span class="comment">// 当前 Derivation 记录到全局的 trackingDerivation 中，这样被观察的 Observable 在其 reportObserved 方法中</span></span><br><span class="line">  <span class="comment">// 就能获取到该 Derivation</span></span><br><span class="line">  <span class="keyword">const</span> prevTracking = globalState.trackingDerivation</span><br><span class="line">  globalState.trackingDerivation = derivation</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行响应函数，收集使用到的所有依赖，加入 newObserving 数组中</span></span><br><span class="line">    result = f.call(context)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    result = <span class="keyword">new</span> CaughtException(e)</span><br><span class="line">  &#125;</span><br><span class="line">  globalState.trackingDerivation = prevTracking</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较新旧依赖，更新依赖</span></span><br><span class="line">  bindDependencies(derivation)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意响应函数调用时不仅仅是执行了该函数，还触发了所有被观察的 Observable 的 reportObserved 方法，从而更新了当前 Derivation 的 newObserving 数组。这部分内容可以回顾第二篇。</p><p>再来看看 bindDependencies 方法如何更新依赖：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindDependencies</span>(<span class="params">derivation: IDerivation</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevObserving = derivation.observing</span><br><span class="line">  <span class="keyword">const</span> observing = (derivation.observing = derivation.newObserving!)</span><br><span class="line">  <span class="comment">// 记录更新依赖过程中，新观察的 Derivation 的最新状态</span></span><br><span class="line">  <span class="keyword">let</span> lowestNewObservingDerivationState = IDerivationState.UP_TO_DATE</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历新的 observing 数组，使用 diffValue 这个属性来辅助 diff 过程：</span></span><br><span class="line">  <span class="comment">// 所有 Observable 的 diffValue 初值都是0（要么刚被创建，继承自 BaseAtom 的初值0；</span></span><br><span class="line">  <span class="comment">// 要么经过上次的 bindDependencies 后，置为了0）</span></span><br><span class="line">  <span class="comment">// 如果 diffValue 为0，保留该 Observable，并将 diffValue 置为1</span></span><br><span class="line">  <span class="comment">// 如果 diffValue 为1，说明是重复的依赖，无视掉</span></span><br><span class="line">  <span class="keyword">let</span> i0 = <span class="number">0</span>,</span><br><span class="line">l = derivation.unboundDepsCount</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = observing[i]</span><br><span class="line">    <span class="keyword">if</span> (dep.diffValue === <span class="number">0</span>) &#123;</span><br><span class="line">      dep.diffValue = <span class="number">1</span></span><br><span class="line">      <span class="comment">// i0 不等于 i，即前面有重复的 dep 被无视，依次往前移覆盖</span></span><br><span class="line">      <span class="keyword">if</span> (i0 !== i) observing[i0] = dep</span><br><span class="line">      i0++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 lowestNewObservingDerivationState </span></span><br><span class="line">    <span class="keyword">if</span> (((dep <span class="keyword">as</span> <span class="built_in">any</span>) <span class="keyword">as</span> IDerivation).dependenciesState &gt; lowestNewObservingDerivationState) &#123;</span><br><span class="line">      lowestNewObservingDerivationState = ((dep <span class="keyword">as</span> <span class="built_in">any</span>) <span class="keyword">as</span> IDerivation).dependenciesState</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  observing.length = i0</span><br><span class="line"></span><br><span class="line">derivation.newObserving = <span class="literal">null</span> </span><br><span class="line">  <span class="comment">// 遍历 prevObserving 数组，检查 diffValue：(经过上一次的 bindDependencies后，该数组中不会有重复)</span></span><br><span class="line">  <span class="comment">// 如果为0，说明没有在 newObserving 中出现，调用 removeObserver 将 dep 和 derivation 间的联系移除</span></span><br><span class="line">  <span class="comment">// 如果为1，依然被观察，将 diffValue 置为0（在下面的循环有用处）</span></span><br><span class="line">  l = prevObserving.length</span><br><span class="line">  <span class="keyword">while</span> (l--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = prevObserving[l]</span><br><span class="line">    <span class="keyword">if</span> (dep.diffValue === <span class="number">0</span>) &#123;</span><br><span class="line">      removeObserver(dep, derivation)</span><br><span class="line">    &#125;</span><br><span class="line">    dep.diffValue = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 再次遍历新的 observing 数组，检查 diffValue</span></span><br><span class="line">  <span class="comment">// 如果为0，说明是在上面的循环中置为了0，即是本来就被观察的依赖，什么都不做</span></span><br><span class="line">  <span class="comment">// 如果为1，说明是新增的依赖，调用 addObserver 新增依赖，并将 diffValue 置为0，为下一次 bindDependencies 做准备</span></span><br><span class="line">  <span class="keyword">while</span> (i0--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = observing[i0]</span><br><span class="line">    <span class="keyword">if</span> (dep.diffValue === <span class="number">1</span>) &#123;</span><br><span class="line">      dep.diffValue = <span class="number">0</span></span><br><span class="line">      addObserver(dep, derivation)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 某些新观察的 Derivation 可能在依赖更新过程中过期</span></span><br><span class="line">  <span class="comment">// 避免这些 Derivation 没有机会传播过期的信息（#916）</span></span><br><span class="line">  <span class="keyword">if</span> (lowestNewObservingDerivationState !== IDerivationState.UP_TO_DATE) &#123;</span><br><span class="line">    derivation.dependenciesState = lowestNewObservingDerivationState</span><br><span class="line">    derivation.onBecomeStale()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>朴素算法比较新旧 observing 数组的时间复杂度为 O(n^2)，这里借助 diffValue 属性的辅助将复杂度降到了 O(n)。</p><p>这样 Reaction 的执行完成，其依赖也得到了更新。当依赖发生变化后，Reaction 会被加入 pendingReactions 中，并重复上述过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Reaction 是一类的特殊的 Derivation，可以注册响应函数，使之在条件满足时自动执行。常用于触发副作用，比如打印日志、更新 DOM 或者发送网络请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mobx" scheme="http://guochen-whu.github.io/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>Mobx 源码解读（三） Modifier</title>
    <link href="http://guochen-whu.github.io/2017/11/16/Mobx-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89-Modifier/"/>
    <id>http://guochen-whu.github.io/2017/11/16/Mobx-源码解读（三）-Modifier/</id>
    <published>2017-11-16T03:57:35.000Z</published>
    <updated>2017-12-02T04:02:09.922Z</updated>
    
    <content type="html"><![CDATA[<p>前面讨论 Observable 时，提到 Mobx 默认使用 deepEnhancer 来包装生成可观察的值，即递归地将该值的属性或元素（如果有）都转换成可观察的。Mobx 提供了五种类型的 Modifier，可以改变这种默认行为，本篇文章我们来看看 Modifier 的原理和实现。</p><a id="more"></a><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Modifier 可以作为 decorator、与 extendObservable 或 observable.object 一起使用，改变某一对象属性的默认转换行为。</p><p>比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> store = observable(&#123;</span><br><span class="line">  users: observable.shallow([])</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 modifier 会将该属性包装成如下形式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  initialValue: [], <span class="comment">// 属性值</span></span><br><span class="line">  enhancer: shallowEnhancer, <span class="comment">// 不同 Modifier 使用不同的 enhancer</span></span><br><span class="line">  isMobxModifierDescriptor: <span class="literal">true</span> <span class="comment">// 标志位，用于 defineObservablePropertyFromDescriptor 函数中的判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在 defineObservablePropertyFromDescriptor 时：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是 Modifier 的描述符，取出值和enhancer</span></span><br><span class="line"><span class="keyword">if</span> (isModifierDescriptor(descriptor.value)) &#123;</span><br><span class="line">  <span class="keyword">const</span> modifierDescriptor = descriptor.value <span class="keyword">as</span> IModifierDescriptor&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">  defineObservableProperty(</span><br><span class="line">    adm,</span><br><span class="line">    propName,</span><br><span class="line">    modifierDescriptor.initialValue,</span><br><span class="line">    modifierDescriptor.enhancer</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就能取出指定的 enhancer 去包装可观察的值了。</p><p>使用了 Modifier 的属性转换成 「可观察的值」后，其 enhancer 属性会将相应 enhancer 保存下来。下一次设置该属性值时，在 prepareNewValue 方法中将新值也使用 enhancer 去包装：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> prepareNewValue(newValue): T | IUNCHANGED &#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="comment">// 应用 Modifier</span></span><br><span class="line">  newValue = <span class="keyword">this</span>.enhancer(newValue, <span class="keyword">this</span>.value, <span class="keyword">this</span>.name)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value !== newValue ? newValue : UNCHANGED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Modifier 不光作用于「当前值」，对于将来设置的值也会生效。</p><h2 id="五种类型的-Modifier"><a href="#五种类型的-Modifier" class="headerlink" title="五种类型的 Modifier"></a>五种类型的 Modifier</h2><p>来看看五种 Modifier 的作用和实现原理。</p><h3 id="observable-deep"><a href="#observable-deep" class="headerlink" title="observable.deep"></a>observable.deep</h3><p>这是默认的 Modifier，使用 deepEnhancer 对值进行包装。</p><p>deepEnhancer 我们已经很熟悉了，它会递归地在可观察对象的属性或可观察数组、Map 的元素上调用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEnhancer</span>(<span class="params">v, _, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isObservable(v)) <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">  <span class="comment">// observable 的这三个方法内部递归使用 deepEnhancer 创建可观察值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(v)) <span class="keyword">return</span> observable.array(v, name)</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(v)) <span class="keyword">return</span> observable.object(v, name)</span><br><span class="line">  <span class="keyword">if</span> (isES6Map(v)) <span class="keyword">return</span> observable.map(v, name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="observable-ref"><a href="#observable-ref" class="headerlink" title="observable.ref"></a>observable.ref</h3><p>referenceEnhancer 不对传入的值进行转换，直接返回：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">referenceEnhancer</span>(<span class="params">newValue?</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="observable-shallow"><a href="#observable-shallow" class="headerlink" title="observable.shallow"></a>observable.shallow</h3><p>shallowEnhancer 只转换 Object, Array, Map 本身，不对其属性（或元素）转换：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEnhancer</span>(<span class="params">v, _, name</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isModifierDescriptor(v))</span><br><span class="line">    fail(</span><br><span class="line">      <span class="string">"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (v === <span class="literal">undefined</span> || v === <span class="literal">null</span>) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// 不对 Object, Array 和 Map 的属性（元素）进行处理</span></span><br><span class="line">  <span class="keyword">if</span> (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// shallow 系列的方法使用 referenceEnhancer，不对属性（元素）进行转换</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(v)) <span class="keyword">return</span> observable.shallowArray(v, name)</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(v)) <span class="keyword">return</span> observable.shallowObject(v, name)</span><br><span class="line">  <span class="keyword">if</span> (isES6Map(v)) <span class="keyword">return</span> observable.shallowMap(v, name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fail(</span><br><span class="line">    <span class="string">"The shallow modifier / decorator can only used in combination with arrays, objects and maps"</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="observable-struct-和-observable-ref-struct"><a href="#observable-struct-和-observable-ref-struct" class="headerlink" title="observable.struct 和 observable.ref.struct"></a>observable.struct 和 observable.ref.struct</h3><p>structEnhancer 表示可观察的「结构」，比如一个窗口大小对象，由长宽组成：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  width: <span class="number">100</span>,</span><br><span class="line">  height: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>structEnhancer 会使用 deepEqual 比较长宽是否发生变化，发生变化时才会通知观察者。即使窗口大小对象的引用发生变化而长宽值不变，也不会通知观察者。</p><p>structEnhancer 也分两种：deepStructEnhancer 和 refStructEnhancer，也就是说前者会在修饰属性值的属性上继续递归，将其转换成可观察的「结构」，而后者不会递归执行。</p><p>使用 structEnhancer 后，设置属性时，就可以看到 Enhancer 的第二个参数的作用了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepStructEnhancer</span>(<span class="params">v, oldValue, name</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// set 时，深比较新旧值，如果相等，就不包装直接返回了</span></span><br><span class="line">  <span class="comment">// 这样 prepareNewValue 中判断没有变化，就不会发送通知</span></span><br><span class="line">  <span class="keyword">if</span> (deepEqual(v, oldValue)) <span class="keyword">return</span> oldValue</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObservable(v)) <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(v)) <span class="keyword">return</span> <span class="keyword">new</span> ObservableArray(v, deepStructEnhancer, name)</span><br><span class="line">  <span class="keyword">if</span> (isES6Map(v)) <span class="keyword">return</span> <span class="keyword">new</span> ObservableMap(v, deepStructEnhancer, name)</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(v)) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    asObservableObject(res, name)</span><br><span class="line">    extendObservableHelper(res, deepStructEnhancer, [v])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refStructEnhancer</span>(<span class="params">v, oldValue, name</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (deepEqual(v, oldValue)) <span class="keyword">return</span> oldValue</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作为-Decorator-使用的-Modifier"><a href="#作为-Decorator-使用的-Modifier" class="headerlink" title="作为 Decorator 使用的 Modifier"></a>作为 Decorator 使用的 Modifier</h2><p>Modifier 经常作为 Decorator 使用，装饰一个属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Message &#123;</span><br><span class="line">  <span class="comment">// 相当于 @observable.deep</span></span><br><span class="line">  <span class="meta">@observable</span> message = <span class="string">'Hello world'</span></span><br><span class="line">  <span class="meta">@observable</span>.ref author = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mobx 对这种用法做了适配，以 observable.deep 为例。</p><p>我们知道，属性装饰器本质上就是一个参数与 Object.defineProperty 一致的函数，它返回一个新的属性描述符，并把这个新的描述符作用在目标属性上。因此 observable 和 observable.deep 中根据参数判断是否是作为属性装饰器使用：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObservable</span>(<span class="params">v: <span class="built_in">any</span> = <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// observable 作为装饰器装饰某属性</span></span><br><span class="line">  <span class="comment">// arguments[1] 为属性名，string 类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">1</span>] === <span class="string">"string"</span>) <span class="keyword">return</span> deepDecorator.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deep() &#123;</span><br><span class="line">  <span class="comment">// 作为函数调用，参数为需要包装的值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> createModifierDescriptor(deepEnhancer, <span class="built_in">arguments</span>[<span class="number">0</span>]) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 作为装饰器使用</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> deepDecorator.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 deepDecorator 由 createDecoratorForEnhancer 函数生成：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDecoratorForEnhancer</span>(<span class="params">enhancer: IEnhancer&lt;<span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createClassPropertyDecorator(</span><br><span class="line">    (target, name, baseValue, _, baseDescriptor) =&gt; &#123;</span><br><span class="line">      assertPropertyConfigurable(target, name)</span><br><span class="line">      invariant(!baseDescriptor || !baseDescriptor.get, getMessage(<span class="string">"m022"</span>))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 先获取 admin 对象</span></span><br><span class="line">      <span class="keyword">const</span> adm = asObservableObject(target, <span class="literal">undefined</span>)</span><br><span class="line">      <span class="comment">// 然后在 admin 对象上使用指定 enhancer 定义属性即可</span></span><br><span class="line">      defineObservableProperty(adm, name, baseValue, enhancer)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> observable = <span class="keyword">this</span>.$mobx.values[name]</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        observable === <span class="literal">undefined</span></span><br><span class="line">      )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">return</span> observable.get()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">      setPropertyValue(<span class="keyword">this</span>, name, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span>,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createClassPropertyDecorator 是一个工具函数，主要为了解决 ts 和 Babel 在处理 Decorator 时的差异。该函数返回一个通用的装饰器函数，签名如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classPropertyDecorator</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">    customArgs?: IArguments,</span></span></span><br><span class="line"><span class="function"><span class="params">    argLen: <span class="built_in">number</span> = 0</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个装饰器函数内部会先执行 createClassPropertyDecorator 传入的第一个函数，可以看到，这里传入的函数执行过程和第二篇中描述的在对象上定义可观察属性是一致的。然后这个装饰器函数内部会分别设置 get, set 访问器为第二、三个参数，可以看到，形式与 generateObservablePropConfig 中定义的也是一致的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面讨论 Observable 时，提到 Mobx 默认使用 deepEnhancer 来包装生成可观察的值，即递归地将该值的属性或元素（如果有）都转换成可观察的。Mobx 提供了五种类型的 Modifier，可以改变这种默认行为，本篇文章我们来看看 Modifier 的原理和实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mobx" scheme="http://guochen-whu.github.io/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>Mobx 源码解读（二） Observable</title>
    <link href="http://guochen-whu.github.io/2017/11/15/Mobx-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89-Observable/"/>
    <id>http://guochen-whu.github.io/2017/11/15/Mobx-源码解读（二）-Observable/</id>
    <published>2017-11-15T13:56:22.000Z</published>
    <updated>2017-11-30T14:24:22.506Z</updated>
    
    <content type="html"><![CDATA[<p>Mobx 提供了三种可观察的数据类型：对象、数组和 Map。Mobx 内部做了大量的工作，使它们的使用体验和原生 JS 类型一致，通过 observable api 包装后就可以转换成可观察值，使用时无须额外的方法调用。对于其它类型的值，Mobx 提供了 observable.box，包装之后使用其 get, set 方法来获取和设置值，也可以达到「可观察」的效果。</p><p>第一篇中提到，Observable 使用 reportObserved 和 propagateChanged 函数通知自身「被观察」和「发生变化」。将值变得可观察的关键步骤就在于触发这两个函数的调用，先来看看不同类型的 Observable 是如何实现这一点的。</p><a id="more"></a><h2 id="如何变得「可观察」"><a href="#如何变得「可观察」" class="headerlink" title="如何变得「可观察」"></a>如何变得「可观察」</h2><p>Mobx 提供的 API observable，实际上是一个工厂函数 createObservable：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObservable</span>(<span class="params">v: <span class="built_in">any</span> = <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// observable 作为属性装饰器使用</span></span><br><span class="line">  <span class="comment">// 默认使用 deepDecorator，它是 deepEnhancer 对应的 Decorator</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">1</span>] === <span class="string">"string"</span>) <span class="keyword">return</span> deepDecorator.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isObservable(v)) <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认使用 deepEnhancer 包装</span></span><br><span class="line">  <span class="keyword">const</span> res = deepEnhancer(v, <span class="literal">undefined</span>, <span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包装后转换为了「可观察的」的数据结构</span></span><br><span class="line">  <span class="keyword">if</span> (res !== v) <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则，调用 observable.box 包装</span></span><br><span class="line">  <span class="keyword">return</span> observable.box(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 observable api</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> observable: IObservableFactory &amp;</span><br><span class="line">  IObservableFactories &amp; &#123;</span><br><span class="line">    deep: &#123;</span><br><span class="line">      struct&lt;T&gt;(initialValue?: T): T</span><br><span class="line">    &#125;</span><br><span class="line">    ref: &#123;</span><br><span class="line">      struct&lt;T&gt;(initialValue?: T): T</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; = createObservable <span class="keyword">as</span> <span class="built_in">any</span></span><br></pre></td></tr></table></figure><p>deepEnhancer 是 Mobx 默认的 Modifier（关于 Modifier 可以参看第三篇），会对对象、数组和 Map 进行处理：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepEnhancer</span>(<span class="params">v, _, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isObservable(v)) <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(v)) <span class="keyword">return</span> observable.array(v, name)</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(v)) <span class="keyword">return</span> observable.object(v, name)</span><br><span class="line">  <span class="keyword">if</span> (isES6Map(v)) <span class="keyword">return</span> observable.map(v, name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对于其他类型的值，deepEnhancer 原样返回，从而在 createObservable 中会使用 observable.box 进行包装。先来看看最简单的 observable.box 如何使传入的值可观察。</p><h3 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h3><p>observable.box 方法简单地返回一个 ObservableValue 实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box&lt;T&gt;(value?: T, name?: <span class="built_in">string</span>): IObservableValue&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) incorrectlyUsedAsDecorator(<span class="string">"box"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ObservableValue(value, deepEnhancer, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObservableValue 实现了 get 和 set 方法，用户在使用时自行使用这两个方法获取和设置「可观察原始值」的值，那么实现「可观察」就只需在这两个方法内分别去调用 reportObserved 和 reportChanged 即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">set</span>(newValue: T) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">  newValue = <span class="keyword">this</span>.prepareNewValue(newValue) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">if</span> (newValue !== UNCHANGED) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 发生变化，设置新值</span></span><br><span class="line">    <span class="keyword">this</span>.setNewValue(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一些新值的预处理工作</span></span><br><span class="line"><span class="keyword">private</span> prepareNewValue(newValue): T | IUNCHANGED &#123;</span><br><span class="line">  <span class="comment">// 检查两个边界情况</span></span><br><span class="line">  checkIfStateModificationsAreAllowed(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 经过 Enhancer 包装</span></span><br><span class="line">  newValue = <span class="keyword">this</span>.enhancer(newValue, <span class="keyword">this</span>.value, <span class="keyword">this</span>.name)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.value !== newValue ? newValue : UNCHANGED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setNewValue(newValue: T) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">  <span class="keyword">this</span>.value = newValue</span><br><span class="line">  <span class="comment">// reportChanged 方法继承自 BaseAtom</span></span><br><span class="line">  <span class="keyword">this</span>.reportChanged()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">get</span>(): T &#123;</span><br><span class="line">  <span class="comment">// reportObserved 方法继承自 BaseAtom</span></span><br><span class="line">  <span class="keyword">this</span>.reportObserved()</span><br><span class="line">  <span class="comment">// 使用 Enhancer 相应的 Dehancer 获取包装前的值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dehanceValue(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>observable.object 方法将对象变为可观察的，它实际上是把对象的所有属性转换为可观察的，存放到一个代理对象上，以减少对原对象的污染：</p><p><img src="./ObservableObject示意图.png" alt="ObservableObject示意图"></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observable.object</span></span><br><span class="line">object&lt;T&gt;(props: T, name?: <span class="built_in">string</span>): T &amp; IObservableObject &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) incorrectlyUsedAsDecorator(<span class="string">"object"</span>)</span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">  <span class="comment">// 创建代理对象</span></span><br><span class="line">  asObservableObject(res, name)</span><br><span class="line">  <span class="comment">// 添加可观察属性</span></span><br><span class="line">  extendObservable(res, props)</span><br><span class="line">  <span class="keyword">return</span> res <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>asObservableObject 函数为对象创建一个「可观察对象」作为代理对象，按照源码中的命名，我们称之为「admin 对象」。admin 对象的 target 属性指向原对象，并作为隐藏属性添加到原对象上。它的实现如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asObservableObject</span>(<span class="params">target, name?: <span class="built_in">string</span></span>): <span class="title">ObservableObjectAdministration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// admin 对象已经存在，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (isObservableObject(target) &amp;&amp; target.hasOwnProperty(<span class="string">"$mobx"</span>)) <span class="keyword">return</span> (target <span class="keyword">as</span> <span class="built_in">any</span>).$mobx</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(target))</span><br><span class="line">    name = (target.constructor.name || <span class="string">"ObservableObject"</span>) + <span class="string">"@"</span> + getNextId()</span><br><span class="line">  <span class="keyword">if</span> (!name) name = <span class="string">"ObservableObject@"</span> + getNextId()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 admin 对象</span></span><br><span class="line">  <span class="keyword">const</span> adm = <span class="keyword">new</span> ObservableObjectAdministration(target, name)</span><br><span class="line">  <span class="comment">// 作为隐藏属性添加到原对象上</span></span><br><span class="line">  addHiddenFinalProp(target, <span class="string">"$mobx"</span>, adm)</span><br><span class="line">  <span class="keyword">return</span> adm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>admin 对象通过 addHiddenFinalProp 方法，作为一个隐藏属性添加到原对象上。使用 ES5 的 Object.defineProperty 定义一个不可枚举的属性即可实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addHiddenProp</span>(<span class="params">object: <span class="built_in">any</span>, propName: <span class="built_in">string</span>, value: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(object, propName, &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>admin 对象的 values 属性上用于存放原对象的属性，不同的是，这些属性都是经过 Enhancer 包装过的可观察属性。</p><p>接下来就是调用 extendObservable 来生成这些可观察属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendObservable</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Object</span>, <span class="title">B</span> <span class="title">extends</span> <span class="title">Object</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: A,</span></span></span><br><span class="line"><span class="function"><span class="params">  ...properties: B[] <span class="comment">// 可以接受多组 props</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">A</span> &amp; <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 deepEnhancer，对复杂类型的属性会递归执行</span></span><br><span class="line">  <span class="keyword">return</span> extendObservableHelper(target, deepEnhancer, properties) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendObservableHelper</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  defaultEnhancer: IEnhancer&lt;<span class="built_in">any</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  properties: <span class="built_in">Object</span>[]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> adm = asObservableObject(target)</span><br><span class="line">  <span class="comment">// 避免多组 props 可能有重复</span></span><br><span class="line">  <span class="keyword">const</span> definedProps = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = properties.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> propSet = properties[i]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> propSet)</span><br><span class="line">      <span class="keyword">if</span> (definedProps[key] !== <span class="literal">true</span> &amp;&amp; hasOwnProperty(propSet, key)) &#123;</span><br><span class="line">        definedProps[key] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> ((target <span class="keyword">as</span> <span class="built_in">any</span>) === propSet &amp;&amp; !isPropertyConfigurable(target, key)) <span class="keyword">continue</span> <span class="comment">// #111</span></span><br><span class="line">        <span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(propSet, key)</span><br><span class="line">        <span class="comment">// 根据属性描述符定义可观察属性</span></span><br><span class="line">        defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defineObservablePropertyFromDescriptor 函数根据属性描述符来定义可观察属性，它是一个通用的函数，后面我们还会多次看到这个函数。对于对象属性，会进入 defineObservableProperty 分支：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineObservablePropertyFromDescriptor</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  adm: ObservableObjectAdministration,</span></span></span><br><span class="line"><span class="function"><span class="params">  propName: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  descriptor: PropertyDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">  defaultEnhancer: IEnhancer&lt;<span class="built_in">any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 已经是可观察属性</span></span><br><span class="line">  <span class="keyword">if</span> (adm.values[propName] &amp;&amp; !isComputedValue(adm.values[propName])) &#123;</span><br><span class="line">    invariant(</span><br><span class="line">      <span class="string">"value"</span> <span class="keyword">in</span> descriptor,</span><br><span class="line">      <span class="string">`The property <span class="subst">$&#123;propName&#125;</span> in <span class="subst">$&#123;adm.name&#125;</span> is already observable, cannot redefine it as computed property`</span></span><br><span class="line">    )</span><br><span class="line">    adm.target[propName] = descriptor.value</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该属性是数据属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) &#123;</span><br><span class="line">    <span class="comment">// 如果是 Modifier 的描述符，取出值和enhancer</span></span><br><span class="line">    <span class="keyword">if</span> (isModifierDescriptor(descriptor.value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> modifierDescriptor = descriptor.value <span class="keyword">as</span> IModifierDescriptor&lt;<span class="built_in">any</span>&gt;</span><br><span class="line">      defineObservableProperty(</span><br><span class="line">        adm,</span><br><span class="line">        propName,</span><br><span class="line">        modifierDescriptor.initialValue,</span><br><span class="line">        modifierDescriptor.enhancer</span><br><span class="line">      )</span><br><span class="line">    <span class="comment">// Action</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAction(descriptor.value) &amp;&amp; descriptor.value.autoBind === <span class="literal">true</span>) &#123;</span><br><span class="line">      defineBoundAction(adm.target, propName, descriptor.value.originalFn)</span><br><span class="line">    <span class="comment">// 计算值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isComputedValue(descriptor.value)) &#123;</span><br><span class="line">      defineComputedPropertyFromComputedValue(adm, propName, descriptor.value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 定义可观察属性</span></span><br><span class="line">      defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 访问器属性（即计算值）</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defineComputedProperty(</span><br><span class="line">      adm,</span><br><span class="line">      propName,</span><br><span class="line">      descriptor.get,</span><br><span class="line">      descriptor.set,</span><br><span class="line">      comparer.default,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defineObservableProperty 为对象定义可观察属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineObservableProperty</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  adm: ObservableObjectAdministration,</span></span></span><br><span class="line"><span class="function"><span class="params">  propName: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue,</span></span></span><br><span class="line"><span class="function"><span class="params">  enhancer: IEnhancer&lt;<span class="built_in">any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性定义成一个 ObservableValue 实例，存放在 admin 对象的 values 属性上</span></span><br><span class="line">  <span class="comment">// 注意这里使用的是 deepEnhancer，意味着对于属性值是复杂对象的情形，在实例化</span></span><br><span class="line">  <span class="comment">// ObservableValue 时会递归执行「将对象转换为可观察对象」的过程，从而使得 values </span></span><br><span class="line">  <span class="comment">// 上的属性都是可观察的</span></span><br><span class="line">  <span class="keyword">const</span> observable = (adm.values[propName] = <span class="keyword">new</span> ObservableValue(</span><br><span class="line">    newValue,</span><br><span class="line">    enhancer,</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;adm.name&#125;</span>.<span class="subst">$&#123;propName&#125;</span>`</span>,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  ))</span><br><span class="line">  newValue = (observable <span class="keyword">as</span> <span class="built_in">any</span>).value</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义访问器属性</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(adm.target, propName, generateObservablePropConfig(propName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来了，前面提到，ObservableValue 实现了 get 和 set 方法，对于原始值，由用户负责主动调用这两个方法，从而触发 reportObserved 和 reportChanged（实际上是在 setNewValue 方法中触发）。</p><p>那么对于可观察属性，将其包装成 ObservableValue 实例存放在 admin 对象上之后，如何触发 get 和 setNewValue 方法呢？答案是利用访问器属性，generateObservablePropConfig 为属性生成访问器属性描述符，在 get 和 set 访问器中触发相应 ObservableValue 实例的 get 和 setNewValue 方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observablePropertyConfigs = &#123;&#125; <span class="comment">// 属性描述符缓存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateObservablePropConfig</span>(<span class="params">propName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    observablePropertyConfigs[propName] ||</span><br><span class="line">    (observablePropertyConfigs[propName] = &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 admin 对象上存放的相应 ObservableValue 实例的 get 方法</span></span><br><span class="line">        <span class="comment">// 从而触发 reportObserved</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$mobx.values[propName].get()</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        setPropertyValue(<span class="keyword">this</span>, propName, v)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPropertyValue</span>(<span class="params">instance, name: <span class="built_in">string</span>, newValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> adm = instance.$mobx</span><br><span class="line">  <span class="keyword">const</span> observable = adm.values[name]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预处理</span></span><br><span class="line">  newValue = observable.prepareNewValue(newValue)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 值发生变化</span></span><br><span class="line">  <span class="keyword">if</span> (newValue !== UNCHANGED) &#123;</span><br><span class="line">    <span class="comment">// setNewValue 会触发 reportChanged</span></span><br><span class="line">    observable.setNewValue(newValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经历完这一系列步骤后，最后返回的就是一个可观察的对象了。</p><p>还有一点需要注意的是，因为 extendObservable 中使用的是 deepEnhancer，意味着在 defineObservableProperty 函数中，实例化 ObservableValue 时，如果该属性的值是复杂对象，会递归执行「将对象转换为可观察的」过程，从而使得该属性的所有属性（或元素）也都是可观察的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableValue 的构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value: T,</span></span><br><span class="line"><span class="params">  <span class="keyword">protected</span> enhancer: IEnhancer&lt;T&gt;,</span></span><br><span class="line">  name = "ObservableValue@" + getNextId(),</span><br><span class="line">  notifySpy = <span class="literal">true</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">super</span>(name)</span><br><span class="line">  <span class="comment">// 递归调用 deepEnhancer</span></span><br><span class="line">  <span class="keyword">this</span>.value = enhancer(value, <span class="literal">undefined</span>, name)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Mobx 实现了一个扩展的数组类型，ObservableArray，来支持数组的可观察。observable.array 方法返回一个 ObservableArray 实例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observable.array 工厂方法</span></span><br><span class="line">array&lt;T&gt;(initialValues?: T[], name?: <span class="built_in">string</span>): IObservableArray&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) incorrectlyUsedAsDecorator(<span class="string">"array"</span>)</span><br><span class="line">  <span class="comment">// 返回一个 ObservableArray 实例，使用 deepEnhancer 对各数组项进行包装</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ObservableArray(initialValues, deepEnhancer, name) <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与对象不同的是，数组的「属性名」都是一样的，即0,1,2…这样的索引。Mobx 利用原型链，在 ObservableArray 的原型上添加 0,1,2…等访问器属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录 Observable.prototype 上访问器属性的数量</span></span><br><span class="line"><span class="keyword">let</span> OBSERVABLE_ARRAY_BUFFER_SIZE = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增访问器属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reserveArrayBuffer</span>(<span class="params">max: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = OBSERVABLE_ARRAY_BUFFER_SIZE; index &lt; max; index++)</span><br><span class="line">    createArrayBufferItem(index)</span><br><span class="line">  OBSERVABLE_ARRAY_BUFFER_SIZE = max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrayBufferItem</span>(<span class="params">index: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(ObservableArray.prototype, <span class="string">""</span> + index, createArrayEntryDescriptor(index))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问器属性描述符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrayEntryDescriptor</span>(<span class="params">index: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用 ObservableArray 实例的 get 方法，带上存放在闭包内的索引</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.get(index)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用 ObservableArray 实例的 set 方法</span></span><br><span class="line">      <span class="keyword">this</span>.set(index, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化时先添加1000个索引属性</span></span><br><span class="line">reserveArrayBuffer(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>这样，使用索引访问 ObservableArray 实例中的元素时，顺着原型链查找到相应属性，就会调用 ObservableArray 实例的 get 和 set 方法了，同时带上相应的索引值。</p><p>Mobx 初始化时，会在 ObservableArray.prototype 上添加1000个这样的索引属性，当数组长度超过1000时，再通过 reserveArrayBuffer 函数来扩充 ObservableArray.prototype 上索引属性的数量。</p><p>也就是说，ObservableArray 实例上并没有0,1,2…等属性，那么数组项存放在哪呢？</p><p>和对象的处理类似，每一个 ObservableArray 实例都有一个对应的 ObservableArrayAdministration 实例来管理数组项，数组的每一项都会转换成「可观察的」之后，存放在 admin 对象的 values 属性上，这个属性是一个原生 JS 数组。</p><p>ObservableArray, ObservableArray.prototype, ObservableArrayAdministration 三者之间的关系如下图所示：</p><p><img src="./ObservableArray示意图.png" alt="ObservableArray示意图"></p><p>来看看一个可观察的数组的初始化过程：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableArray 的构造函数</span></span><br><span class="line"><span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">  initialValues: T[] | <span class="literal">undefined</span>,</span></span><br><span class="line"><span class="params">  enhancer: IEnhancer&lt;T&gt;,</span></span><br><span class="line">  name = "ObservableArray@" + getNextId(),</span><br><span class="line">  owned = <span class="literal">false</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">super</span>()</span><br><span class="line">  <span class="comment">// 创建 admin 对象，并作为不可枚举、不可修改的属性添加到 ObservableArray 实例上</span></span><br><span class="line">  <span class="keyword">const</span> adm = <span class="keyword">new</span> ObservableArrayAdministration&lt;T&gt;(name, enhancer, <span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>, owned)</span><br><span class="line">  addHiddenFinalProp(<span class="keyword">this</span>, <span class="string">"$mobx"</span>, adm)</span><br><span class="line">  <span class="comment">// 添加传入的数组项到 admin 对象的 values 属性上</span></span><br><span class="line">  <span class="keyword">if</span> (initialValues &amp;&amp; initialValues.length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.spliceWithArray(<span class="number">0</span>, <span class="number">0</span>, initialValues)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spliceWithArray 方法直接调用了 admin 对象上的同名方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableArrayAdministration.prototype.spliceWithArray</span></span><br><span class="line">spliceWithArray(index: <span class="built_in">number</span>, deleteCount?: <span class="built_in">number</span>, newItems?: T[]): T[] &#123;</span><br><span class="line">  checkIfStateModificationsAreAllowed(<span class="keyword">this</span>.atom)</span><br><span class="line">  <span class="keyword">const</span> length = <span class="keyword">this</span>.values.length</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一堆参数的处理</span></span><br><span class="line">  <span class="keyword">if</span> (index === <span class="literal">undefined</span>) index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; length) index = length</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="built_in">Math</span>.max(<span class="number">0</span>, length + index)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) deleteCount = length - index</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (deleteCount === <span class="literal">undefined</span> || deleteCount === <span class="literal">null</span>) deleteCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> deleteCount = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="built_in">Math</span>.min(deleteCount, length - index))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newItems === <span class="literal">undefined</span>) newItems = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重点：遍历新增的数组项，返回经过 enhancer 包装后的</span></span><br><span class="line">  newItems = &lt;T[]&gt;newItems.map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">this</span>.enhancer(v, <span class="literal">undefined</span>))</span><br><span class="line">  <span class="keyword">const</span> lengthDelta = newItems.length - deleteCount</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 更新 length</span></span><br><span class="line">  <span class="keyword">this</span>.updateArrayLength(length, lengthDelta)</span><br><span class="line">  <span class="comment">// 更新 values 数组</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">this</span>.spliceItemsIntoValues(index, deleteCount, newItems)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (deleteCount !== <span class="number">0</span> || newItems.length !== <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 通知变化</span></span><br><span class="line">    <span class="keyword">this</span>.notifyArraySplice(index, newItems, res)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 和原生 splice 方法一样，返回删除的数组项</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dehanceValues(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就得到了一个可观察的数组。</p><p>当我们访问数组项时，如前文所述，Observable.prototype 上的索引属性被访问，并通过 get 访问器调用 ObservableArray 实例的 get 方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(index: <span class="built_in">number</span>): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">  <span class="comment">// 获取 admin 对象</span></span><br><span class="line">  <span class="keyword">const</span> impl = &lt;ObservableArrayAdministration&lt;<span class="built_in">any</span>&gt;&gt;<span class="keyword">this</span>.$mobx</span><br><span class="line">  <span class="keyword">if</span> (impl) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; impl.values.length) &#123;</span><br><span class="line">      <span class="comment">// admin 对象上的 Atom 实例通知数组被观察</span></span><br><span class="line">      impl.atom.reportObserved()</span><br><span class="line">      <span class="comment">// 返回经过 dehancer 处理的原始数组项</span></span><br><span class="line">      <span class="keyword">return</span> impl.dehanceValue(impl.values[index])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接通过索引修改数组项的值时，set 访问器会调用 ObservableArray 实例的 set 方法，同样也是由 admin 对象负责数组项的更新和变化通知：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(index: <span class="built_in">number</span>, newValue: T) &#123;</span><br><span class="line">  <span class="keyword">const</span> adm = &lt;ObservableArrayAdministration&lt;T&gt;&gt;<span class="keyword">this</span>.$mobx</span><br><span class="line">  <span class="keyword">const</span> values = adm.values</span><br><span class="line">  <span class="keyword">if</span> (index &lt; values.length) &#123;</span><br><span class="line">    checkIfStateModificationsAreAllowed(adm.atom)</span><br><span class="line">    <span class="keyword">const</span> oldValue = values[index]</span><br><span class="line">    newValue = adm.enhancer(newValue, oldValue)</span><br><span class="line">    <span class="keyword">const</span> changed = newValue !== oldValue</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      values[index] = newValue</span><br><span class="line">      <span class="comment">// notifyArrayChildUpdate 方法内会调用 atom 实例的 reportChanged 方法发送变化通知</span></span><br><span class="line">      adm.notifyArrayChildUpdate(index, newValue, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === values.length) &#123;</span><br><span class="line">    <span class="comment">// 添加一个元素</span></span><br><span class="line">    adm.spliceWithArray(index, <span class="number">0</span>, [newValue])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 抛出错误...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mobx 中数组的 length 属性也是可观察的，原理也是一样的，都是利用原型链，在 Observable.prototype 上定义有 length 访问器属性，这里不再赘述。</p><p>为了得到类似原生数组的使用体验，ObservableArray 实现了所有原生数组的方法。来看看具体的实现方式。</p><p>对于 map, slice, toString 等不修改原数组的方法，只是在调用之前发送被观察通知：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">;[</span><br><span class="line">  <span class="string">"every"</span>,</span><br><span class="line">  <span class="string">"filter"</span>,</span><br><span class="line">  <span class="string">"forEach"</span>,</span><br><span class="line">  <span class="string">"indexOf"</span>,</span><br><span class="line">  <span class="string">"join"</span>,</span><br><span class="line">  <span class="string">"lastIndexOf"</span>,</span><br><span class="line">  <span class="string">"map"</span>,</span><br><span class="line">  <span class="string">"reduce"</span>,</span><br><span class="line">  <span class="string">"reduceRight"</span>,</span><br><span class="line">  <span class="string">"slice"</span>,</span><br><span class="line">  <span class="string">"some"</span>,</span><br><span class="line">  <span class="string">"toString"</span>,</span><br><span class="line">  <span class="string">"toLocaleString"</span></span><br><span class="line">].forEach(<span class="function"><span class="params">funcName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> baseFunc = <span class="built_in">Array</span>.prototype[funcName]</span><br><span class="line">  addHiddenProp(ObservableArray.prototype, funcName, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 先调用 peek 方法，发送被观察通知</span></span><br><span class="line">    <span class="comment">// 然后在返回的数组项上调用方法</span></span><br><span class="line">    <span class="keyword">return</span> baseFunc.apply(<span class="keyword">this</span>.peek(), <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObservableArray.prototype.peek</span></span><br><span class="line">peek(): T[] &#123;</span><br><span class="line">  <span class="comment">// 发送被观察通知</span></span><br><span class="line">  <span class="keyword">this</span>.$mobx.atom.reportObserved()</span><br><span class="line">  <span class="comment">// 返回原始数组项供方法使用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.$mobx.dehanceValues(<span class="keyword">this</span>.$mobx.values)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于会修改原数组的方法，调用 admin 对象上的方法进行操作，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableArray.prototype.push</span></span><br><span class="line">push(...items: T[]): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> adm = <span class="keyword">this</span>.$mobx</span><br><span class="line">  <span class="comment">// spliceWithArray 方法内部会发送变化通知</span></span><br><span class="line">  adm.spliceWithArray(adm.values.length, <span class="number">0</span>, items)</span><br><span class="line">  <span class="keyword">return</span> adm.values.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>与数组的处理类似，Mobx 也实现了一个 ObservableMap 类，不过只支持字符串、数字或布尔值作为键。ObservableMap 在可观察对象的基础上，还要使键的增删可观察。它可以看做两个可观察映射和一个可观察数组的组合：</p><p><img src="./ObservableMap示意.png" alt="ObservableMap示意"></p><p>这里的可观察映射指的是属性值可观察而对象属性不可观察，相当于 ObservableObjectAdministration 的 values 属性。_data 存放键到可观察值的映射，_hasMap 存放键是否存在的映射。_keys 属性是一个 ObservableArray 实例，存放所有的键，从而使键的增删可观察。</p><p>三者配合从而得到一个可观察粒度比对象更细的 Map。例如一个使用了 get 方法的 Derivation 只观察该键值对的变化，而不会观察其它键值对的设置和增删：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = observable(<span class="keyword">new</span> Map());</span><br><span class="line"></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(map.get(<span class="string">'key'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'key'</span>, <span class="string">'value'</span>); <span class="comment">// 新增 key-value 键值对，输出 value</span></span><br><span class="line">map.set(<span class="string">'key'</span>, <span class="string">'anotherValue'</span>); <span class="comment">// 修改为 key-anotherValue，输出 anotherValue</span></span><br><span class="line">map.set(<span class="string">'prop'</span>, <span class="string">'value'</span>); <span class="comment">// 不输出</span></span><br><span class="line">map.delete(<span class="string">'prop'</span>); <span class="comment">// 不输出</span></span><br></pre></td></tr></table></figure><p>来看 get 方法的实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>(key: <span class="built_in">string</span>): V | <span class="literal">undefined</span> &#123;</span><br><span class="line">  key = <span class="string">""</span> + key</span><br><span class="line">  <span class="comment">// 如果存在该键值对，触发该值的 reportObserved</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.has(key)) <span class="keyword">return</span> <span class="keyword">this</span>.dehanceValue(<span class="keyword">this</span>._data[key]!.get())</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.dehanceValue(<span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">has(key: <span class="built_in">string</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.isValidKey(key)) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  key = <span class="string">""</span> + key</span><br><span class="line">  <span class="comment">// _hasMap 中对应值(observable(bool))发送观察通知</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._hasMap[key]) <span class="keyword">return</span> <span class="keyword">this</span>._hasMap[key].get()</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._updateHasMapEntry(key, <span class="literal">false</span>).get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，这个 Derivation 只收集了这个键对应的值和表示是否存在该键的布尔值作为依赖，因而只对该键的值变化和该键值对的增删作出响应。</p><p>再比如使用了 keys 方法的 Derivation 只观察键值对的增删，而使用了 values 方法的 Derivation 同时观察键值对的增删和值的变化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">keys(): <span class="built_in">string</span>[] &amp; Iterator&lt;<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="comment">// _keys.slice 触发 _keys 的被观察通知</span></span><br><span class="line">  <span class="keyword">return</span> arrayAsIterator(<span class="keyword">this</span>._keys.slice())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">values(): V[] &amp; Iterator&lt;V&gt; &#123;</span><br><span class="line">  <span class="comment">// _keys.map 触发 _keys 的被观察通知</span></span><br><span class="line">  <span class="comment">// 依次调用 this.get 触发每一个可观察值的被观察通知</span></span><br><span class="line">  <span class="keyword">return</span> (arrayAsIterator <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="keyword">this</span>._keys.map(<span class="keyword">this</span>.get, <span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送被观察通知"><a href="#发送被观察通知" class="headerlink" title="发送被观察通知"></a>发送被观察通知</h2><p>接下来看看 reportObserved 是如何发送通知的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reportObserved</span>(<span class="params">observable: IObservable</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 从全局状态中取出当前正在跟踪的 Derivation</span></span><br><span class="line">  <span class="keyword">const</span> derivation = globalState.trackingDerivation</span><br><span class="line">  <span class="keyword">if</span> (derivation !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 一处简单的性能优化，如果是同一次 Derivation 执行访问到 Observable</span></span><br><span class="line"><span class="comment">      * 直接忽略</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (derivation.runId !== observable.lastAccessedBy) &#123;</span><br><span class="line">      observable.lastAccessedBy = derivation.runId</span><br><span class="line">      <span class="comment">// 将 Observable 加入衍生的 newObserving 数组中，</span></span><br><span class="line">      <span class="comment">// 同时更新 unboundDepsCount（新增的依赖数量）</span></span><br><span class="line">      derivation.newObserving![derivation.unboundDepsCount++] = observable</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果 Observable 不再有观察者时，将他加入到一个全局队列中待处理</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (observable.observers.length === <span class="number">0</span>) &#123;</span><br><span class="line">    queueForUnobservation(observable)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reportObserved 函数从全局状态中取出当前正在执行的 Derivation，把 Observable 加入其 newObserving 数组中。Derivation 执行完后，会比较新旧 observing 数组，重新计算出依赖（这部分内容可以参看第四篇）。</p><h2 id="发送变化通知"><a href="#发送变化通知" class="headerlink" title="发送变化通知"></a>发送变化通知</h2><p>再来看 propageteChanged 是如何发送变化通知的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">propagateChanged</span>(<span class="params">observable: IObservable</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果该 Observable 的所有观察者都已经处于过期状态，就没有必要发送过期通知了</span></span><br><span class="line">  <span class="keyword">if</span> (observable.lowestObserverState === IDerivationState.STALE) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 标记所有观察者都处于过期状态</span></span><br><span class="line">  observable.lowestObserverState = IDerivationState.STALE</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历所有观察者，将它们的 dependenciesState 标志设为过期，表示有依赖过期，需要重新计算</span></span><br><span class="line">  <span class="keyword">const</span> observers = observable.observers</span><br><span class="line">  <span class="keyword">let</span> i = observers.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> d = observers[i]</span><br><span class="line">    <span class="comment">// 如果依赖由最新变为过期，调用该观察者的 onBecomeStale 方法</span></span><br><span class="line">    <span class="keyword">if</span> (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale()</span><br><span class="line">    d.dependenciesState = IDerivationState.STALE</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，propagateChanged 只是将 Observable 和它的观察者们的标志设为了过期，并没有实际执行任何的重新计算。在一个 Derivation 的依赖由最新变为过期时，会调用它的 onBecomeStale 方法。</p><p>Reaction 的 onBecomeStale 方法只是简单的调用了 schedule 方法，将该 Reaction 的更新「加入了一个计划表内」：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">onBecomeStale() &#123;</span><br><span class="line">  <span class="keyword">this</span>.schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">schedule() &#123;</span><br><span class="line">  <span class="comment">// 已经在重新计算的计划表内，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._isScheduled) &#123;</span><br><span class="line">    <span class="keyword">this</span>._isScheduled = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 该 Reaction 加入全局的待重新计算数组中</span></span><br><span class="line">    globalState.pendingReactions.push(<span class="keyword">this</span>)</span><br><span class="line">    runReactions()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这张计划表实际上就是一个全局的数组，放置的是当前批次需要重新执行的所有 Reaction。<br>紧接着调用了 runReactions 函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReactions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 此时处于事务中，inBatch &gt; 0，会直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (globalState.inBatch &gt; <span class="number">0</span> || globalState.isRunningReactions) <span class="keyword">return</span></span><br><span class="line">  reactionScheduler(runReactionsHelper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情形下 runReactions 实际不会执行 Reaction 的重新计算，因为此时至少会处于一个事务当中，即 Observable 在调用 reportChanged 时所开始的事务。</p><p>第四篇中我们将会看到，Derivation 是如何根据 Observalbe 的通知，动态更新自身的依赖或执行重新计算的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mobx 提供了三种可观察的数据类型：对象、数组和 Map。Mobx 内部做了大量的工作，使它们的使用体验和原生 JS 类型一致，通过 observable api 包装后就可以转换成可观察值，使用时无须额外的方法调用。对于其它类型的值，Mobx 提供了 observable.box，包装之后使用其 get, set 方法来获取和设置值，也可以达到「可观察」的效果。&lt;/p&gt;
&lt;p&gt;第一篇中提到，Observable 使用 reportObserved 和 propagateChanged 函数通知自身「被观察」和「发生变化」。将值变得可观察的关键步骤就在于触发这两个函数的调用，先来看看不同类型的 Observable 是如何实现这一点的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mobx" scheme="http://guochen-whu.github.io/tags/Mobx/"/>
    
  </entry>
  
  <entry>
    <title>Mobx 源码解读（一） 基本概念</title>
    <link href="http://guochen-whu.github.io/2017/11/14/Mobx-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://guochen-whu.github.io/2017/11/14/Mobx-源码解读（一）-基本概念/</id>
    <published>2017-11-14T13:38:59.000Z</published>
    <updated>2017-12-02T03:44:53.241Z</updated>
    
    <content type="html"><![CDATA[<p>项目中使用 Mobx 有一段时间了，与 Redux 相比，自己最直观的感受就是避免了 Redux 中大量的样板代码。不需要再去写 action creator, reducer 等，应用的状态直接在 Action 内修改，Mobx 会自动管理依赖的更新和副作用的触发。</p><p>由于想看看 Mobx 是如何实现优雅的状态管理，于是花时间研究了下 Mobx 源码。通过这几篇文章记录一些自己的理解，作为以后项目中的参考，避免项目中可能踩到的各种坑。</p><a id="more"></a><p>具体分析源码之前有必要先理清 Mobx 中的几个概念：</p><h2 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h2><p>事务的概念大家都不陌生，通常表示一组原子性的操作。Mobx 中的事务用于批量处理 Reaction 的执行，避免不必要的重新计算。Mobx 的事务实现比较简单，使用 startBatch 和 endBatch 来开始和结束一个事务：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startBatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过一个全局的变量 inBatch 标识事务嵌套的层级</span></span><br><span class="line">  globalState.inBatch++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">endBatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 最外层事务结束时，才开始执行重新计算</span></span><br><span class="line">  <span class="keyword">if</span> (--globalState.inBatch === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行所有 Reaction</span></span><br><span class="line">    runReactions()</span><br><span class="line">    <span class="comment">// 处理不再被观察的 Observable</span></span><br><span class="line">    <span class="keyword">const</span> list = globalState.pendingUnobservations</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> observable = list[i]</span><br><span class="line">      observable.isPendingUnobservation = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> (observable.observers.length === <span class="number">0</span>) &#123;</span><br><span class="line">          observable.onBecomeUnobserved()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    globalState.pendingUnobservations = []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，事务可以嵌套，直到最外层事务结束之后，才会重新执行 Reaction。用一张图来形象地表示事务的概念：</p><p><img src="./事务图解.png" alt="事务图解"></p><p>例如，一个 Action 开始和结束时同时伴随着事务的启动和结束，确保 Action 中（可能多次）对状态的修改只触发一次 Reaction 的重新执行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  startBatch()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">endAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  endBatch()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h2><p>任何能用于存储应用状态的值在 Mobx 中称为 Atom，它会在「被观察时」和「自身发生变化时」发送通知。BaseAtom 基类定义了实现「可观察」的几个关键属性和方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BaseAtom <span class="keyword">implements</span> IAtom &#123;</span><br><span class="line">  <span class="comment">// 标志属性，不再被观察时为 true</span></span><br><span class="line">  isPendingUnobservation = <span class="literal">true</span> </span><br><span class="line">  <span class="comment">// 观察者数组</span></span><br><span class="line">  observers = []</span><br><span class="line">  <span class="comment">// 观察者数组的映射</span></span><br><span class="line">  observersIndexes = &#123;&#125;</span><br><span class="line">  <span class="comment">// 用于比较 Derivation 的新旧依赖</span></span><br><span class="line">  diffValue = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 上一次被使用时，Derivation 的 runId</span></span><br><span class="line">  lastAccessedBy = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 状态最新的观察者所处的状态</span></span><br><span class="line">  lowestObserverState = IDerivationState.NOT_TRACKING</span><br><span class="line"></span><br><span class="line">  constructor(public name = "Atom@" + getNextId()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> onBecomeUnobserved() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 被使用时触发</span></span><br><span class="line">  <span class="keyword">public</span> reportObserved() &#123;</span><br><span class="line">    reportObserved(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发生变化时触发</span></span><br><span class="line">  <span class="keyword">public</span> reportChanged() &#123;</span><br><span class="line">    startBatch()</span><br><span class="line">    propagateChanged(<span class="keyword">this</span>)</span><br><span class="line">    endBatch()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObservableValue 正是继承自 BaseAtom。可以看到，reportObserverd 和 reportChanged 分别调用了 reportObserved 和 propagateChanged 两个方法，这正是 Observable 用于「通知被观察」和「通知自身变化」的两个函数。</p><p>Atom 可以说是具有「可观察」功能的最小类型，Mobx 也将它作为 API 导出，让用户能够基于它定制一些可观察的数据类型。</p><h2 id="Derivation"><a href="#Derivation" class="headerlink" title="Derivation"></a>Derivation</h2><p>Derivation 即能够从当前状态「衍生」出来的对象，包括计算值和 Reaction。Mobx 中通过 Derivation 注册响应函数，响应函数中所使用到的 Observable 称为它的依赖，依赖过期时 Derivation 会重新执行，更新依赖。 </p><p>IDerivation 接口定义的几个重要属性：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IDerivation <span class="keyword">extends</span> IDepTreeNode &#123;</span><br><span class="line">  <span class="comment">// 依赖数组</span></span><br><span class="line">  observing: IObservable[]</span><br><span class="line">  <span class="comment">// 每次执行收集到的新依赖数组</span></span><br><span class="line">  newObserving: <span class="literal">null</span> | IObservable[]</span><br><span class="line">  <span class="comment">// 依赖的状态</span></span><br><span class="line">  dependenciesState: IDerivationState</span><br><span class="line">  <span class="comment">// 每次执行都会有一个 uuid，配合 Observable 的 lastAccessedBy 属性做简单的性能优化</span></span><br><span class="line">  runId: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">// 执行时新收集的未绑定依赖数量</span></span><br><span class="line">  unboundDepsCount: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">// 依赖过期时执行</span></span><br><span class="line">  onBecomeStale()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，Observable 和 Derivation 是双向关联的，分别持有对方的引用。</p><p>Derivation 通过 dependenciesState 属性标记依赖的四种状态：</p><ol><li><p>NOT_TRACKING</p><p>在执行之前，或事务之外，或未被观察(计算值)时，所处的状态。此时 Derivation 没有任何关于依赖树的信息。枚举值-1</p></li><li><p>UP_TO_DATE</p><p>表示所有依赖都是最新的，这种状态下不会重新计算。枚举值0</p></li><li><p>POSSIBLY_STALE</p><p>计算值才有的状态，表示深依赖发生了变化，但不能确定浅依赖是否变化，在重新计算之前会检查。枚举值1</p></li><li><p>STALE</p><p>过期状态，即浅依赖发生了变化，Derivation 需要重新计算。枚举值2</p></li></ol><p>源码中经常能见到 lowestState 之类的变量，表示的是「状态最新的观察者所处的状态」。</p><p>接下来是几个在源码中随处可见的概念。</p><h2 id="invariant"><a href="#invariant" class="headerlink" title="invariant"></a>invariant</h2><p>Mobx 从 React 借鉴了 invariant，在条件为 false 时抛出错误：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span>(<span class="params">check: <span class="built_in">boolean</span>, message: <span class="built_in">string</span>, thing?</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!check)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"[mobx] Invariant failed: "</span> + message + (thing ? <span class="string">` in '<span class="subst">$&#123;thing&#125;</span>'`</span> : <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有基于 invariant 的 fail：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">message: <span class="built_in">string</span>, thing?</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  invariant(<span class="literal">false</span>, message, thing)</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"X"</span> <span class="comment">// unreachable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spy-intercept-和-observe"><a href="#spy-intercept-和-observe" class="headerlink" title="spy, intercept 和 observe"></a>spy, intercept 和 observe</h2><p>在 Mobx 源码中，经常可以看到为实现 spy, intercept 和 observe 插入的大段代码。</p><p>spy 可以监听 Mobx 中发生的所有事件，包括可观察值的变化、Action 的执行、Derivation 的计算等，典型的应用就是 <code>mobx-react-devtools</code>。</p><p>典型的实现 spy 的代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件开始前</span></span><br><span class="line"><span class="keyword">const</span> notify = isSpyEnabled()</span><br><span class="line"><span class="keyword">let</span> startTime</span><br><span class="line"><span class="keyword">if</span> (notify) &#123;</span><br><span class="line">  startTime = <span class="built_in">Date</span>.now()</span><br><span class="line">  spyReportStart(&#123;</span><br><span class="line">    object: <span class="keyword">this</span>,</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">"reaction"</span>,</span><br><span class="line">    fn</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件结束后</span></span><br><span class="line"><span class="keyword">if</span> (notify) &#123;</span><br><span class="line">  spyReportEnd(&#123;</span><br><span class="line">    time: <span class="built_in">Date</span>.now() - startTime</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>intercept 和 observe 可以在 observable 变化前后设置钩子函数。</p><p>intercept 可以在 observable 变化前对该变化做出修改，包括取消该变化，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableValue 变化时</span></span><br><span class="line"><span class="keyword">if</span> (hasInterceptors(<span class="keyword">this</span>)) &#123;</span><br><span class="line">  <span class="comment">// intercept 修改变化</span></span><br><span class="line">  <span class="keyword">const</span> change = interceptChange&lt;IValueWillChange&lt;T&gt;&gt;(<span class="keyword">this</span>, &#123;</span><br><span class="line">      object: <span class="keyword">this</span>,</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"update"</span>,</span><br><span class="line">      newValue</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// change 为 null，可以取消修改</span></span><br><span class="line">  <span class="keyword">if</span> (!change) <span class="keyword">return</span> UNCHANGED</span><br><span class="line">  newValue = change.newValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observe 会响应所有的变化，即使处在事务中，例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObservableValue 的 setNewValue 方法</span></span><br><span class="line">setNewValue(newValue: T) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">  <span class="keyword">this</span>.value = newValue</span><br><span class="line">  <span class="keyword">this</span>.reportChanged()</span><br><span class="line">  <span class="comment">// 立即通知 listeners</span></span><br><span class="line">  <span class="keyword">if</span> (hasListeners(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    notifyListeners(<span class="keyword">this</span>, &#123;</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"update"</span>,</span><br><span class="line">      object: <span class="keyword">this</span>,</span><br><span class="line">      newValue,</span><br><span class="line">      oldValue</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简洁起见，接下来几篇文章引用的源码中都会忽略这部分代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中使用 Mobx 有一段时间了，与 Redux 相比，自己最直观的感受就是避免了 Redux 中大量的样板代码。不需要再去写 action creator, reducer 等，应用的状态直接在 Action 内修改，Mobx 会自动管理依赖的更新和副作用的触发。&lt;/p&gt;
&lt;p&gt;由于想看看 Mobx 是如何实现优雅的状态管理，于是花时间研究了下 Mobx 源码。通过这几篇文章记录一些自己的理解，作为以后项目中的参考，避免项目中可能踩到的各种坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mobx" scheme="http://guochen-whu.github.io/tags/Mobx/"/>
    
  </entry>
  
</feed>
